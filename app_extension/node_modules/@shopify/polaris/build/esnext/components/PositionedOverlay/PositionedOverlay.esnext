import React, { PureComponent } from 'react';
import { classNames } from '../../utilities/css.esnext';
import { getRectForNode, Rect } from '../../utilities/geometry.esnext';
import { dataPolarisTopBar, layer } from '../shared.esnext';
import { windowRect, calculateVerticalPosition, calculateHorizontalPosition, rectIsOutsideOfRect, intersectionWithViewport } from './utilities/math.esnext';
import styles from './PositionedOverlay.scss.esnext';
import { Scrollable } from '../Scrollable/Scrollable.esnext';
import { EventListener } from '../EventListener/EventListener.esnext';

const OBSERVER_CONFIG = {
  childList: true,
  subtree: true,
  characterData: true,
  attributeFilter: ['style']
};
class PositionedOverlay extends PureComponent {
  state = {
    measuring: true,
    activatorRect: getRectForNode(this.props.activator),
    right: undefined,
    left: undefined,
    top: 0,
    height: 0,
    width: null,
    positioning: 'below',
    zIndex: null,
    outsideScrollableContainer: false,
    lockPosition: false,
    chevronOffset: 0
  };
  overlay = null;
  scrollableContainers = [];
  constructor(props) {
    super(props);
    this.observer = new MutationObserver(this.handleMeasurement);
  }
  componentDidMount() {
    this.setScrollableContainers();
    if (this.scrollableContainers.length && !this.props.fixed) {
      this.registerScrollHandlers();
    }
    this.handleMeasurement();
  }
  componentWillUnmount() {
    this.observer.disconnect();
    if (this.scrollableContainers.length && !this.props.fixed) {
      this.unregisterScrollHandlers();
    }
  }
  componentDidUpdate() {
    const {
      outsideScrollableContainer,
      top
    } = this.state;
    const {
      onScrollOut,
      active
    } = this.props;
    if (active && onScrollOut != null && top !== 0 && outsideScrollableContainer) {
      onScrollOut();
    }
  }
  render() {
    const {
      left,
      right,
      top,
      zIndex,
      width
    } = this.state;
    const {
      render,
      fixed,
      preventInteraction,
      classNames: propClassNames,
      zIndexOverride
    } = this.props;
    const style = {
      top: top == null || isNaN(top) ? undefined : top,
      left: left == null || isNaN(left) ? undefined : left,
      right: right == null || isNaN(right) ? undefined : right,
      width: width == null || isNaN(width) ? undefined : width,
      zIndex: zIndexOverride || zIndex || undefined
    };
    const className = classNames(styles.PositionedOverlay, fixed && styles.fixed, preventInteraction && styles.preventInteraction, propClassNames);
    return /*#__PURE__*/React.createElement("div", {
      className: className,
      style: style,
      ref: this.setOverlay
    }, /*#__PURE__*/React.createElement(EventListener, {
      event: "resize",
      handler: this.handleMeasurement
    }), render(this.overlayDetails()));
  }
  get firstScrollableContainer() {
    return this.scrollableContainers[0] ?? null;
  }
  forceUpdatePosition() {
    // Wait a single animation frame before re-measuring.
    // Consumer's may also need to setup their own timers for
    // triggering forceUpdatePosition() `children` use animation.
    // Ideally, forceUpdatePosition() is fired at the end of a transition event.
    requestAnimationFrame(this.handleMeasurement);
  }
  overlayDetails = () => {
    const {
      measuring,
      left,
      right,
      positioning,
      height,
      activatorRect,
      chevronOffset
    } = this.state;
    return {
      measuring,
      left,
      right,
      desiredHeight: height,
      positioning,
      activatorRect,
      chevronOffset
    };
  };
  setOverlay = node => {
    this.overlay = node;
  };
  setScrollableContainers = () => {
    const containers = [];
    let scrollableContainer = Scrollable.forNode(this.props.activator);
    if (scrollableContainer) {
      containers.push(scrollableContainer);
      while (scrollableContainer?.parentElement) {
        scrollableContainer = Scrollable.forNode(scrollableContainer.parentElement);
        containers.push(scrollableContainer);
      }
    }
    this.scrollableContainers = containers;
  };
  registerScrollHandlers = () => {
    this.scrollableContainers.forEach(node => {
      node.addEventListener('scroll', this.handleMeasurement);
    });
  };
  unregisterScrollHandlers = () => {
    this.scrollableContainers.forEach(node => {
      node.removeEventListener('scroll', this.handleMeasurement);
    });
  };
  handleMeasurement = () => {
    const {
      lockPosition,
      top
    } = this.state;
    this.observer.disconnect();
    this.setState(({
      left,
      top,
      right
    }) => ({
      left,
      right,
      top,
      height: 0,
      positioning: 'below',
      measuring: true
    }), () => {
      if (this.overlay == null || this.firstScrollableContainer == null) {
        return;
      }
      const {
        activator,
        preferredPosition = 'below',
        preferredAlignment = 'center',
        onScrollOut,
        fullWidth,
        fixed,
        preferInputActivator = true
      } = this.props;
      const preferredActivator = preferInputActivator ? activator.querySelector('input') || activator : activator;
      const activatorRect = getRectForNode(preferredActivator);
      const currentOverlayRect = getRectForNode(this.overlay);
      const scrollableElement = isDocument(this.firstScrollableContainer) ? document.body : this.firstScrollableContainer;
      const scrollableContainerRect = getRectForNode(scrollableElement);
      const overlayRect = fullWidth ? new Rect({
        ...currentOverlayRect,
        width: activatorRect.width
      }) : currentOverlayRect;

      // If `body` is 100% height, it still acts as though it were not constrained to that size. This adjusts for that.
      if (scrollableElement === document.body) {
        scrollableContainerRect.height = document.body.scrollHeight;
      }
      let topBarOffset = 0;
      const topBarElement = scrollableElement.querySelector(`${dataPolarisTopBar.selector}`);
      if (topBarElement) {
        topBarOffset = topBarElement.clientHeight;
      }
      const overlayMargins = this.overlay.firstElementChild && this.overlay.firstChild instanceof HTMLElement ? getMarginsForNode(this.overlay.firstElementChild) : {
        activator: 0,
        container: 0,
        horizontal: 0
      };
      const containerRect = windowRect();
      const zIndexForLayer = getZIndexForLayerFromNode(activator);
      const zIndex = zIndexForLayer == null ? zIndexForLayer : zIndexForLayer + 1;
      const verticalPosition = calculateVerticalPosition(activatorRect, overlayRect, overlayMargins, scrollableContainerRect, containerRect, preferredPosition, fixed, topBarOffset);
      const horizontalPosition = calculateHorizontalPosition(activatorRect, overlayRect, containerRect, overlayMargins, preferredAlignment);
      const chevronOffset = activatorRect.center.x - horizontalPosition + overlayMargins.horizontal * 2;
      this.setState({
        measuring: false,
        activatorRect: getRectForNode(activator),
        left: preferredAlignment !== 'right' ? horizontalPosition : undefined,
        right: preferredAlignment === 'right' ? horizontalPosition : undefined,
        top: lockPosition ? top : verticalPosition.top,
        lockPosition: Boolean(fixed),
        height: verticalPosition.height || 0,
        width: fullWidth ? overlayRect.width : null,
        positioning: verticalPosition.positioning,
        outsideScrollableContainer: onScrollOut != null && rectIsOutsideOfRect(activatorRect, intersectionWithViewport(scrollableContainerRect)),
        zIndex,
        chevronOffset
      }, () => {
        if (!this.overlay) return;
        this.observer.observe(this.overlay, OBSERVER_CONFIG);
        this.observer.observe(activator, OBSERVER_CONFIG);
      });
    });
  };
}
function getMarginsForNode(node) {
  const nodeStyles = window.getComputedStyle(node);
  return {
    activator: parseFloat(nodeStyles.marginTop || '0'),
    container: parseFloat(nodeStyles.marginBottom || '0'),
    horizontal: parseFloat(nodeStyles.marginLeft || '0')
  };
}
function getZIndexForLayerFromNode(node) {
  const layerNode = node.closest(layer.selector) || document.body;
  const zIndex = layerNode === document.body ? 'auto' : parseInt(window.getComputedStyle(layerNode).zIndex || '0', 10);
  return zIndex === 'auto' || isNaN(zIndex) ? null : zIndex;
}
function isDocument(node) {
  return node === document;
}

export { PositionedOverlay };
