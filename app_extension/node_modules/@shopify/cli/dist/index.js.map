{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAC,MAAM,EAAE,qBAAqB,EAAC,MAAM,2BAA2B,CAAA;AACvE,2EAA2E;AAC3E,OAAO,EAAE,MAAM,IAAI,CAAA;AAEnB,kFAAkF;AAClF,mFAAmF;AACnF,kFAAkF;AAClF,qFAAqF;AACrF,kFAAkF;AAClF,2DAA2D;AAC3D,OAAO,CAAC,EAAE,CAAC,mBAAmB,EAAE,CAAC,GAAG,EAAE,EAAE;IACtC,EAAE,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,EAAE,GAAG,GAAG,CAAC,KAAK,IAAI,CAAC,CAAA;IACjD,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;AACjB,CAAC,CAAC,CAAA;AACF,MAAM,OAAO,GAAG,CAAC,QAAQ,EAAE,SAAS,EAAE,SAAS,CAAC,CAAA;AAChD,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;IACzB,OAAO,CAAC,EAAE,CAAC,MAAM,EAAE,GAAG,EAAE;QACtB,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;IACjB,CAAC,CAAC,CAAA;AACJ,CAAC,CAAC,CAAA;AAEF,kFAAkF;AAClF,gCAAgC;AAChC,MAAM,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,mBAAmB,CAAC,CAAA;AACvD,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE;IACnB,OAAO,CAAC,MAAM,CAAC,OAAO,GAAG,OAAO,CAAA;CACjC;AAMD,KAAK,UAAU,aAAa,CAAC,EAAC,WAAW,EAAuB;IAC9D,IAAI,CAAC,WAAW,EAAE;QAChB,uEAAuE;QACvE,MAAM,eAAe,GAAG,MAAM,qBAAqB,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;QACpE,IAAI,eAAe,EAAE;YACnB,OAAM;SACP;KACF;IAED,MAAM,MAAM,CAAC;QACX,SAAS,EAAE,MAAM,CAAC,IAAI,CAAC,GAAG;QAC1B,WAAW;KACZ,CAAC,CAAA;AACJ,CAAC;AAED,eAAe,aAAa,CAAA","sourcesContent":["import {runCLI, useLocalCLIIfDetected} from '@shopify/cli-kit/node/cli'\n// eslint-disable-next-line @shopify/cli/specific-imports-in-bootstrap-code\nimport fs from 'fs'\n\n// In some cases (for example when we boot the proxy server), when an exception is\n// thrown, no 'exit' signal is sent to the process. We don't understand this fully.\n// This means that any cleanup code that depends on \"process.on('exit', ...)\" will\n// not be called. The tunnel plugin is an example of that. Here we make sure to print\n// the error stack and manually call exit so that the cleanup code is called. This\n// makes sure that there are no lingering tunnel processes.\nprocess.on('uncaughtException', (err) => {\n  fs.writeSync(process.stderr.fd, `${err.stack}\\n`)\n  process.exit(1)\n})\nconst signals = ['SIGINT', 'SIGTERM', 'SIGQUIT']\nsignals.forEach((signal) => {\n  process.on(signal, () => {\n    process.exit(1)\n  })\n})\n\n// Sometimes we want to specify a precise amount of stdout columns, for example in\n// CI or on a cloud environment.\nconst columns = Number(process.env.SHOPIFY_CLI_COLUMNS)\nif (!isNaN(columns)) {\n  process.stdout.columns = columns\n}\n\ninterface RunShopifyCLIOptions {\n  development: boolean\n}\n\nasync function runShopifyCLI({development}: RunShopifyCLIOptions) {\n  if (!development) {\n    // If we run a local CLI instead, don't run the global one again after!\n    const ranLocalInstead = await useLocalCLIIfDetected(import.meta.url)\n    if (ranLocalInstead) {\n      return\n    }\n  }\n\n  await runCLI({\n    moduleURL: import.meta.url,\n    development,\n  })\n}\n\nexport default runShopifyCLI\n"]}