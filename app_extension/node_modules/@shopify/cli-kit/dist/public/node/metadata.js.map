{"version":3,"file":"metadata.js","sourceRoot":"","sources":["../../../src/public/node/metadata.ts"],"names":[],"mappings":"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","sourcesContent":["import {isUnitTest} from './context/local.js'\nimport {performance} from 'node:perf_hooks'\nimport type {PickByPrefix} from '../common/ts/pick-by-prefix.js'\nimport type {AnyJson} from '../../private/common/json.js'\nimport type {MonorailEventPublic} from './monorail.js'\n\ntype ProvideMetadata<T> = () => Partial<T> | Promise<Partial<T>>\n\ntype MetadataErrorHandling =\n  // Mute & report errors in production, throw them whilst testing\n  | 'auto'\n  // Errors are not reported to the user and do not stop execution, but they are reported to Bugsnag\n  | 'mute-and-report'\n  // Errors are not caught and will bubble out as normal\n  | 'bubble'\n\n/**\n * Get the error handling strategy for metadata.\n *\n * @returns 'mute-and-report' in production, 'bubble' in tests.\n */\nfunction getMetadataErrorHandlingStrategy(): 'mute-and-report' | 'bubble' {\n  if (isUnitTest()) {\n    return 'bubble'\n  }\n  return 'mute-and-report'\n}\n\n/**\n * Any key in T that has a numeric value.\n */\ntype NumericKeyOf<T> = {\n  [K in keyof T]: T[K] extends number ? (K extends string ? K : never) : never\n}[keyof T]\n\nexport interface RuntimeMetadataManager<TPublic extends AnyJson, TSensitive extends AnyJson> {\n  /** Add some public metadata -- this should not contain any PII. */\n  addPublicMetadata: (getData: ProvideMetadata<TPublic>, onError?: MetadataErrorHandling) => Promise<void>\n  /**\n   * Add some potentially sensitive metadata -- this may include PII, but unnecessary data should never be tracked\n   * (this is a good fit for command args for instance).\n   */\n  addSensitiveMetadata: (getData: ProvideMetadata<TSensitive>, onError?: MetadataErrorHandling) => Promise<void>\n  /** Get a snapshot of the tracked public data. */\n  getAllPublicMetadata: () => Partial<TPublic>\n  /** Get a snapshot of the tracked sensitive data. */\n  getAllSensitiveMetadata: () => Partial<TSensitive>\n  /** Run a function, monitoring how long it takes, and adding the elapsed time to a running total. */\n  runWithTimer: (field: NumericKeyOf<TPublic>) => <T>(fn: () => Promise<T>) => Promise<T>\n}\n\nexport type PublicSchema<T> = T extends RuntimeMetadataManager<infer TPublic, infer _TSensitive> ? TPublic : never\nexport type SensitiveSchema<T> = T extends RuntimeMetadataManager<infer _TPublic, infer TSensitive> ? TSensitive : never\n\n/**\n * Creates a container for metadata collected at runtime.\n * The container provides async-safe functions for extracting the gathered metadata, and for setting it.\n *\n * @param defaultPublicMetadata - Optional, default data for the container.\n * @returns A container for the metadata.\n */\nexport function createRuntimeMetadataContainer<\n  TPublic extends AnyJson,\n  TSensitive extends AnyJson = {[key: string]: never},\n>(defaultPublicMetadata: Partial<TPublic> = {}): RuntimeMetadataManager<TPublic, TSensitive> {\n  const raw: {sensitive: Partial<TSensitive>; public: Partial<TPublic>} = {\n    sensitive: {},\n    public: {\n      ...defaultPublicMetadata,\n    },\n  }\n  const addPublic = (data: Partial<TPublic>) => {\n    Object.assign(raw.public, data)\n  }\n  const addSensitive = (data: Partial<TSensitive>) => {\n    Object.assign(raw.sensitive, data)\n  }\n\n  const addMetadata = async <T>(\n    addFn: (data: Partial<T>) => void,\n    getFn: ProvideMetadata<T>,\n    onError: MetadataErrorHandling,\n  ) => {\n    const errorHandling = onError === 'auto' ? getMetadataErrorHandlingStrategy() : onError\n    const getAndSet = async () => {\n      const data = await getFn()\n      addFn(data)\n    }\n\n    if (errorHandling === 'bubble') {\n      await getAndSet()\n    } else {\n      try {\n        await getAndSet()\n        // eslint-disable-next-line no-catch-all/no-catch-all, @typescript-eslint/no-explicit-any\n      } catch (error: any) {\n        // This is very prone to becoming a circular dependency, so we import it dynamically\n        const {sendErrorToBugsnag} = await import('./error-handler.js')\n        await sendErrorToBugsnag(error, 'unexpected_error')\n      }\n    }\n  }\n\n  // See `runWithTimer` below.\n  const durationStack: number[] = []\n\n  return {\n    getAllPublicMetadata: () => {\n      return {...raw.public}\n    },\n    getAllSensitiveMetadata: () => {\n      return {...raw.sensitive}\n    },\n    addPublicMetadata: async (getData: ProvideMetadata<TPublic>, onError: MetadataErrorHandling = 'auto') => {\n      return addMetadata(addPublic, getData, onError)\n    },\n    addSensitiveMetadata: async (getData: ProvideMetadata<TSensitive>, onError: MetadataErrorHandling = 'auto') => {\n      return addMetadata(addSensitive, getData, onError)\n    },\n    runWithTimer: (field: NumericKeyOf<TPublic>): (<T>(fn: () => Promise<T>) => Promise<T>) => {\n      return async (fn) => {\n        /**\n         * For nested timers, we subtract the inner timer's duration from the outer timer's. We use a stack to track the\n         * cumulative durations of nested timers. On starting a timer, we push a zero onto the stack to initialize the total\n         * duration for subsequent nested timers. Before logging, we pop the stack to get the total nested timers' duration.\n         * We subtract this from the current timer's actual duration to get its measurable duration. We then add the current\n         * timer's actual duration to the stack's top, allowing any parent timer to deduct it from its own duration.\n         */\n\n        // Initialise the running total duration for all nested timers\n        durationStack.push(0)\n\n        // Do the work, and time it\n        const start = performance.now()\n        try {\n          const result = await fn()\n          return result\n        } finally {\n          let end = performance.now()\n          // For very short durations, the end time can be before the start time(!) - we flatten this out to zero.\n          end = Math.max(start, end)\n\n          // The top of the stack is the total time for all nested timers\n          const wallClockDuration = Math.max(end - start, 0)\n          const childDurations = durationStack.pop() as number\n          const duration = Math.max(wallClockDuration - childDurations, 0)\n\n          // If this is the topmost timer, the stack will be empty.\n          if (durationStack.length > 0) {\n            durationStack[durationStack.length - 1] += wallClockDuration\n          }\n\n          // Log it -- we include it in the metadata, but also log via the standard performance API. The TS types for this library are not quite right, so we have to cast to `any` here.\n          performance.measure(`${field}#measurable`, {\n            start,\n            duration,\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          } as any)\n          performance.measure(`${field}#wall`, {\n            start,\n            end,\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          } as any)\n\n          // There might not be a value set, yet\n          let currentValue = (raw.public[field] || 0) as number\n          currentValue += duration\n\n          // TS is not quite smart enough to realise that raw.public[field] must be a numeric type\n          raw.public[field] = currentValue as TPublic[NumericKeyOf<TPublic>]\n        }\n      }\n    },\n  }\n}\n\n// We want to track anything that ends up getting sent to monorail as `cmd_all_*` and\n// `cmd_app_*`\ntype CmdFieldsFromMonorail = PickByPrefix<MonorailEventPublic, 'cmd_all_'> &\n  PickByPrefix<MonorailEventPublic, 'cmd_app_'> &\n  PickByPrefix<MonorailEventPublic, 'cmd_create_app_'>\n\nconst coreData = createRuntimeMetadataContainer<\n  CmdFieldsFromMonorail,\n  {\n    commandStartOptions: {\n      startTime: number\n      startCommand: string\n      startTopic?: string\n      startArgs: string[]\n    }\n  } & {environmentFlags: string}\n>({cmd_all_timing_network_ms: 0, cmd_all_timing_prompts_ms: 0})\n\nexport const {getAllPublicMetadata, getAllSensitiveMetadata, addPublicMetadata, addSensitiveMetadata, runWithTimer} =\n  coreData\n\nexport type Public = PublicSchema<typeof coreData>\nexport type Sensitive = SensitiveSchema<typeof coreData>\n"]}