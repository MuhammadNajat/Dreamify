{"version":3,"file":"ConcurrentOutput.test.js","sourceRoot":"","sources":["../../../../../src/private/node/ui/components/ConcurrentOutput.test.tsx"],"names":[],"mappings":"AAAA,OAAO,EAAC,gBAAgB,EAAC,MAAM,uBAAuB,CAAA;AACtD,OAAO,EAAC,MAAM,EAAC,MAAM,qBAAqB,CAAA;AAC1C,OAAO,EAAC,eAAe,EAAc,MAAM,kCAAkC,CAAA;AAC7E,OAAO,EAAC,QAAQ,EAAC,MAAM,mCAAmC,CAAA;AAC1D,OAAO,KAAK,MAAM,OAAO,CAAA;AACzB,OAAO,EAAC,QAAQ,EAAE,MAAM,EAAE,IAAI,EAAC,MAAM,QAAQ,CAAA;AAG7C,QAAQ,CAAC,kBAAkB,EAAE,GAAG,EAAE;IAChC,IAAI,CAAC,2DAA2D,EAAE,KAAK,IAAI,EAAE;QAC3E,QAAQ;QACR,IAAI,qBAAiC,CAAA;QACrC,IAAI,sBAAkC,CAAA;QAEtC,MAAM,cAAc,GAAG,IAAI,OAAO,CAAO,UAAU,OAAO,EAAE,OAAO;YACjE,qBAAqB,GAAG,OAAO,CAAA;QACjC,CAAC,CAAC,CAAA;QAEF,MAAM,eAAe,GAAG,IAAI,OAAO,CAAO,UAAU,OAAO,EAAE,OAAO;YAClE,sBAAsB,GAAG,OAAO,CAAA;QAClC,CAAC,CAAC,CAAA;QAEF,MAAM,cAAc,GAAG;YACrB,MAAM,EAAE,SAAS;YACjB,MAAM,EAAE,KAAK,EAAE,MAAgB,EAAE,OAAiB,EAAE,OAAoB,EAAE,EAAE;gBAC1E,MAAM,CAAC,KAAK,CAAC,uBAAuB,CAAC,CAAA;gBACrC,MAAM,CAAC,KAAK,CAAC,wBAAwB,CAAC,CAAA;gBACtC,MAAM,CAAC,KAAK,CAAC,uBAAuB,CAAC,CAAA;gBAErC,qBAAqB,EAAE,CAAA;YACzB,CAAC;SACF,CAAA;QAED,MAAM,eAAe,GAAG;YACtB,MAAM,EAAE,UAAU;YAClB,MAAM,EAAE,KAAK,EAAE,MAAgB,EAAE,OAAiB,EAAE,OAAoB,EAAE,EAAE;gBAC1E,MAAM,cAAc,CAAA;gBAEpB,MAAM,CAAC,KAAK,CAAC,wBAAwB,CAAC,CAAA;gBACtC,MAAM,CAAC,KAAK,CAAC,yBAAyB,CAAC,CAAA;gBACvC,MAAM,CAAC,KAAK,CAAC,wBAAwB,CAAC,CAAA;gBAEtC,sBAAsB,EAAE,CAAA;gBAExB,oCAAoC;gBACpC,MAAM,IAAI,OAAO,CAAC,GAAG,EAAE,GAAE,CAAC,CAAC,CAAA;YAC7B,CAAC;SACF,CAAA;QACD,OAAO;QAEP,MAAM,cAAc,GAAG,MAAM,CAC3B,oBAAC,gBAAgB,IAAC,SAAS,EAAE,CAAC,cAAc,EAAE,eAAe,CAAC,EAAE,WAAW,EAAE,IAAI,eAAe,EAAE,CAAC,MAAM,GAAI,CAC9G,CAAA;QAED,MAAM,eAAe,CAAA;QAErB,OAAO;QACP,MAAM,CAAC,QAAQ,CAAC,cAAc,CAAC,SAAS,EAAG,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC,qBAAqB,CAAC;;;;;;;;KAQvF,CAAC,CAAA;IACJ,CAAC,CAAC,CAAA;IAEF,IAAI,CAAC,2DAA2D,EAAE,KAAK,IAAI,EAAE;QAC3E,QAAQ;QACR,MAAM,cAAc,GAAG;YACrB,MAAM,EAAE,SAAS;YACjB,MAAM,EAAE,KAAK,EAAE,MAAgB,EAAE,OAAiB,EAAE,OAAoB,EAAE,EAAE;gBAC1E,MAAM,CAAC,KAAK,CAAC,uBAAuB,CAAC,CAAA;gBACrC,MAAM,CAAC,KAAK,CAAC,wBAAwB,CAAC,CAAA;gBACtC,MAAM,CAAC,KAAK,CAAC,uBAAuB,CAAC,CAAA;gBAErC,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAA;YACzC,CAAC;SACF,CAAA;QAED,OAAO;QAEP,MAAM,cAAc,GAAG,MAAM,CAC3B,oBAAC,gBAAgB,IAAC,SAAS,EAAE,CAAC,cAAc,CAAC,EAAE,WAAW,EAAE,IAAI,eAAe,EAAE,CAAC,MAAM,GAAI,CAC7F,CAAA;QAED,MAAM,aAAa,GAAG,cAAc,CAAC,aAAa,EAAE,CAAA;QAEpD,MAAM,MAAM,CAAC,aAAa,CAAC,CAAC,OAAO,CAAC,YAAY,CAAC,sBAAsB,CAAC,CAAA;QACxE,MAAM,CAAC,aAAa,CAAC,UAAU,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;IAC/C,CAAC,CAAC,CAAA;IAEF,IAAI,CAAC,iHAAiH,EAAE,KAAK,IAAI,EAAE;QACjI,QAAQ;QACR,MAAM,cAAc,GAAG;YACrB,MAAM,EAAE,SAAS;YACjB,MAAM,EAAE,KAAK,EAAE,MAAgB,EAAE,OAAiB,EAAE,OAAoB,EAAE,EAAE;gBAC1E,MAAM,CAAC,KAAK,CAAC,uBAAuB,CAAC,CAAA;gBACrC,MAAM,CAAC,KAAK,CAAC,wBAAwB,CAAC,CAAA;gBACtC,MAAM,CAAC,KAAK,CAAC,uBAAuB,CAAC,CAAA;gBAErC,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAA;YACzC,CAAC;SACF,CAAA;QAED,OAAO;QAEP,MAAM,cAAc,GAAG,MAAM,CAC3B,oBAAC,gBAAgB,IACf,SAAS,EAAE,CAAC,cAAc,CAAC,EAC3B,WAAW,EAAE,IAAI,eAAe,EAAE,CAAC,MAAM,EACzC,gCAAgC,SAChC,CACH,CAAA;QAED,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,CAAA;QACxD,MAAM,CAAC,cAAc,CAAC,aAAa,EAAE,CAAC,UAAU,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;IACjE,CAAC,CAAC,CAAA;IAEF,IAAI,CAAC,+DAA+D,EAAE,KAAK,IAAI,EAAE;QAC/E,MAAM,cAAc,GAAG;YACrB,MAAM,EAAE,SAAS;YACjB,MAAM,EAAE,KAAK,EAAE,MAAgB,EAAE,OAAiB,EAAE,OAAoB,EAAE,EAAE;gBAC1E,MAAM,CAAC,KAAK,CAAC,uBAAuB,CAAC,CAAA;gBACrC,MAAM,CAAC,KAAK,CAAC,wBAAwB,CAAC,CAAA;gBACtC,MAAM,CAAC,KAAK,CAAC,uBAAuB,CAAC,CAAA;YACvC,CAAC;SACF,CAAA;QAED,OAAO;QACP,MAAM,cAAc,GAAG,MAAM,CAC3B,oBAAC,gBAAgB,IAAC,SAAS,EAAE,CAAC,cAAc,CAAC,EAAE,WAAW,EAAE,IAAI,eAAe,EAAE,CAAC,MAAM,GAAI,CAC7F,CAAA;QAED,MAAM,aAAa,GAAG,cAAc,CAAC,aAAa,EAAE,CAAA;QAEpD,MAAM,aAAa,CAAA;QACnB,MAAM,CAAC,aAAa,CAAC,WAAW,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;IAChD,CAAC,CAAC,CAAA;IAEF,IAAI,CAAC,wGAAwG,EAAE,KAAK,IAAI,EAAE;QACxH,MAAM,cAAc,GAAG;YACrB,MAAM,EAAE,SAAS;YACjB,MAAM,EAAE,KAAK,EAAE,MAAgB,EAAE,OAAiB,EAAE,OAAoB,EAAE,EAAE;gBAC1E,MAAM,CAAC,KAAK,CAAC,uBAAuB,CAAC,CAAA;gBACrC,MAAM,CAAC,KAAK,CAAC,wBAAwB,CAAC,CAAA;gBACtC,MAAM,CAAC,KAAK,CAAC,uBAAuB,CAAC,CAAA;YACvC,CAAC;SACF,CAAA;QAED,OAAO;QACP,MAAM,cAAc,GAAG,MAAM,CAC3B,oBAAC,gBAAgB,IACf,gCAAgC,QAChC,SAAS,EAAE,CAAC,cAAc,CAAC,EAC3B,WAAW,EAAE,IAAI,eAAe,EAAE,CAAC,MAAM,GACzC,CACH,CAAA;QAED,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC,CAAA;QAExD,MAAM,CAAC,cAAc,CAAC,aAAa,EAAE,CAAC,WAAW,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;IAClE,CAAC,CAAC,CAAA;AACJ,CAAC,CAAC,CAAA","sourcesContent":["import {ConcurrentOutput} from './ConcurrentOutput.js'\nimport {render} from '../../testing/ui.js'\nimport {AbortController, AbortSignal} from '../../../../public/node/abort.js'\nimport {unstyled} from '../../../../public/node/output.js'\nimport React from 'react'\nimport {describe, expect, test} from 'vitest'\nimport {Writable} from 'stream'\n\ndescribe('ConcurrentOutput', () => {\n  test('renders a stream of concurrent outputs from sub-processes', async () => {\n    // Given\n    let backendPromiseResolve: () => void\n    let frontendPromiseResolve: () => void\n\n    const backendPromise = new Promise<void>(function (resolve, _reject) {\n      backendPromiseResolve = resolve\n    })\n\n    const frontendPromise = new Promise<void>(function (resolve, _reject) {\n      frontendPromiseResolve = resolve\n    })\n\n    const backendProcess = {\n      prefix: 'backend',\n      action: async (stdout: Writable, _stderr: Writable, _signal: AbortSignal) => {\n        stdout.write('first backend message')\n        stdout.write('second backend message')\n        stdout.write('third backend message')\n\n        backendPromiseResolve()\n      },\n    }\n\n    const frontendProcess = {\n      prefix: 'frontend',\n      action: async (stdout: Writable, _stderr: Writable, _signal: AbortSignal) => {\n        await backendPromise\n\n        stdout.write('first frontend message')\n        stdout.write('second frontend message')\n        stdout.write('third frontend message')\n\n        frontendPromiseResolve()\n\n        // await promise that never resolves\n        await new Promise(() => {})\n      },\n    }\n    // When\n\n    const renderInstance = render(\n      <ConcurrentOutput processes={[backendProcess, frontendProcess]} abortSignal={new AbortController().signal} />,\n    )\n\n    await frontendPromise\n\n    // Then\n    expect(unstyled(renderInstance.lastFrame()!.replace(/\\d/g, '0'))).toMatchInlineSnapshot(`\n      \"00:00:00 │ backend  │ first backend message\n      00:00:00 │ backend  │ second backend message\n      00:00:00 │ backend  │ third backend message\n      00:00:00 │ frontend │ first frontend message\n      00:00:00 │ frontend │ second frontend message\n      00:00:00 │ frontend │ third frontend message\n      \"\n    `)\n  })\n\n  test('rejects with the error thrown inside one of the processes', async () => {\n    // Given\n    const backendProcess = {\n      prefix: 'backend',\n      action: async (stdout: Writable, _stderr: Writable, _signal: AbortSignal) => {\n        stdout.write('first backend message')\n        stdout.write('second backend message')\n        stdout.write('third backend message')\n\n        throw new Error('something went wrong')\n      },\n    }\n\n    // When\n\n    const renderInstance = render(\n      <ConcurrentOutput processes={[backendProcess]} abortSignal={new AbortController().signal} />,\n    )\n\n    const renderPromise = renderInstance.waitUntilExit()\n\n    await expect(renderPromise).rejects.toThrowError('something went wrong')\n    expect(renderPromise.isRejected()).toBe(true)\n  })\n\n  test(\"doesn't reject when an error is thrown inside one of the processes and keepRunningAfterProcessesResolve is true\", async () => {\n    // Given\n    const backendProcess = {\n      prefix: 'backend',\n      action: async (stdout: Writable, _stderr: Writable, _signal: AbortSignal) => {\n        stdout.write('first backend message')\n        stdout.write('second backend message')\n        stdout.write('third backend message')\n\n        throw new Error('something went wrong')\n      },\n    }\n\n    // When\n\n    const renderInstance = render(\n      <ConcurrentOutput\n        processes={[backendProcess]}\n        abortSignal={new AbortController().signal}\n        keepRunningAfterProcessesResolve\n      />,\n    )\n\n    await new Promise((resolve) => setTimeout(resolve, 500))\n    expect(renderInstance.waitUntilExit().isRejected()).toBe(false)\n  })\n\n  test('render promise resolves when all processes resolve by default', async () => {\n    const backendProcess = {\n      prefix: 'backend',\n      action: async (stdout: Writable, _stderr: Writable, _signal: AbortSignal) => {\n        stdout.write('first backend message')\n        stdout.write('second backend message')\n        stdout.write('third backend message')\n      },\n    }\n\n    // When\n    const renderInstance = render(\n      <ConcurrentOutput processes={[backendProcess]} abortSignal={new AbortController().signal} />,\n    )\n\n    const renderPromise = renderInstance.waitUntilExit()\n\n    await renderPromise\n    expect(renderPromise.isFulfilled()).toBe(true)\n  })\n\n  test(\"render promise doesn't resolve when all processes resolve and keepRunningAfterProcessesResolve is true\", async () => {\n    const backendProcess = {\n      prefix: 'backend',\n      action: async (stdout: Writable, _stderr: Writable, _signal: AbortSignal) => {\n        stdout.write('first backend message')\n        stdout.write('second backend message')\n        stdout.write('third backend message')\n      },\n    }\n\n    // When\n    const renderInstance = render(\n      <ConcurrentOutput\n        keepRunningAfterProcessesResolve\n        processes={[backendProcess]}\n        abortSignal={new AbortController().signal}\n      />,\n    )\n\n    await new Promise((resolve) => setTimeout(resolve, 500))\n\n    expect(renderInstance.waitUntilExit().isFulfilled()).toBe(false)\n  })\n})\n"]}