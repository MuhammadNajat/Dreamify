{"version":3,"file":"use-select-state.js","sourceRoot":"","sources":["../../../../../src/private/node/ui/hooks/use-select-state.ts"],"names":[],"mappings":"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","sourcesContent":["import {Item} from '../components/SelectInput.js'\nimport {useReducer, useCallback, useMemo, useState} from 'react'\nimport {isDeepStrictEqual} from 'node:util'\n\ntype Option<T> = Item<T>\n\ntype OptionMapItem<T> = Option<T> & {\n  previous: OptionMapItem<T> | undefined\n  next: OptionMapItem<T> | undefined\n  index: number\n}\n\nexport default class OptionMap<T> extends Map<T, OptionMapItem<T>> {\n  readonly first: OptionMapItem<T> | undefined\n\n  constructor(options: Option<T>[]) {\n    const items: [T, OptionMapItem<T>][] = []\n    let firstItem: OptionMapItem<T> | undefined\n    let previous: OptionMapItem<T> | undefined\n    let index = 0\n\n    for (const option of options) {\n      const item = {\n        ...option,\n        previous,\n        next: undefined,\n        index,\n      }\n\n      if (previous) {\n        previous.next = item\n      }\n\n      if (!firstItem) {\n        firstItem = item\n      }\n\n      items.push([option.value, item])\n      index++\n      previous = item\n    }\n\n    super(items)\n    this.first = firstItem\n  }\n}\n\ninterface State<T> {\n  /**\n   * Map where key is option's value and value is option's index.\n   */\n  optionMap: OptionMap<T>\n\n  /**\n   * Number of visible options.\n   */\n  visibleOptionCount: number\n\n  /**\n   * Index of the first visible option.\n   */\n  visibleFromIndex: number\n\n  /**\n   * Index of the last visible option.\n   */\n  visibleToIndex: number\n\n  /**\n   * Value of the previously selected option.\n   */\n  previousValue: T | undefined\n\n  /**\n   * Value of the selected option.\n   */\n  value: T | undefined\n}\n\ntype Action<T> = SelectNextOptionAction<T> | SelectPreviousOptionAction<T> | SelectOptionAction<T> | ResetAction<T>\n\ninterface SelectNextOptionAction<T> {\n  type: 'select-next-option'\n}\n\ninterface SelectPreviousOptionAction<T> {\n  type: 'select-previous-option'\n}\n\ninterface SelectOptionAction<T> {\n  type: 'select-option'\n  option: Option<T>\n}\n\ninterface ResetAction<T> {\n  type: 'reset'\n  state: State<T>\n}\n\nconst reducer = <T>(state: State<T>, action: Action<T>): State<T> => {\n  switch (action.type) {\n    case 'select-next-option': {\n      if (typeof state.value === 'undefined') {\n        return state\n      }\n\n      const item = state.optionMap.get(state.value)\n\n      if (!item) {\n        return state\n      }\n\n      let next = item.next\n\n      while (next && next.disabled) {\n        next = next.next\n      }\n\n      if (!next) {\n        return state\n      }\n\n      const needsToScroll = next.index > state.visibleToIndex\n\n      if (!needsToScroll) {\n        return {\n          ...state,\n          value: next.value,\n        }\n      }\n\n      const nextVisibleToIndex = next.index\n      const nextVisibleFromIndex = nextVisibleToIndex - state.visibleOptionCount + 1\n\n      return {\n        ...state,\n        value: next.value,\n        visibleFromIndex: nextVisibleFromIndex,\n        visibleToIndex: nextVisibleToIndex,\n        previousValue: state.value,\n      }\n    }\n\n    case 'select-previous-option': {\n      if (typeof state.value === 'undefined') {\n        return state\n      }\n\n      const item = state.optionMap.get(state.value)\n\n      if (!item) {\n        return state\n      }\n\n      let previous = item.previous\n\n      while (previous && previous.disabled) {\n        previous = previous.previous\n      }\n\n      if (!previous) {\n        return state\n      }\n\n      const needsToScroll = previous.index < state.visibleFromIndex\n\n      if (!needsToScroll) {\n        return {\n          ...state,\n          value: previous.value,\n        }\n      }\n\n      const nextVisibleFromIndex = previous.index\n      const nextVisibleToIndex = nextVisibleFromIndex + state.visibleOptionCount - 1\n\n      return {\n        ...state,\n        value: previous.value,\n        visibleFromIndex: nextVisibleFromIndex,\n        visibleToIndex: nextVisibleToIndex,\n        previousValue: state.value,\n      }\n    }\n\n    case 'select-option': {\n      const item = state.optionMap.get(action.option.value)\n\n      if (!item) {\n        return state\n      }\n\n      return {\n        ...state,\n        value: item.value,\n        previousValue: state.value,\n      }\n    }\n\n    case 'reset': {\n      return action.state\n    }\n\n    default: {\n      return state\n    }\n  }\n}\n\nexport interface UseSelectStateProps<T> {\n  /**\n   * Number of items to display.\n   *\n   */\n  visibleOptionCount: number\n\n  /**\n   * Options.\n   */\n  options: Option<T>[]\n\n  /**\n   * Initially selected option's value.\n   */\n  defaultValue?: T\n}\n\nexport type SelectState<T> = Pick<State<T>, 'visibleOptionCount' | 'visibleFromIndex' | 'visibleToIndex' | 'value'> & {\n  /**\n   * Visible options.\n   */\n  visibleOptions: (Option<T> & {index: number})[]\n\n  /**\n   * Select next option and scroll the list down, if needed.\n   */\n  selectNextOption: () => void\n\n  /**\n   * Select previous option and scroll the list up, if needed.\n   */\n  selectPreviousOption: () => void\n\n  /**\n   * Select option directly.\n   */\n  selectOption: (option: Option<T>) => void\n}\n\ntype CreateDefaultStateProps<T> = Pick<UseSelectStateProps<T>, 'visibleOptionCount' | 'defaultValue' | 'options'>\n\nconst createDefaultState = <T>({\n  visibleOptionCount: customVisibleOptionCount,\n  defaultValue,\n  options,\n}: CreateDefaultStateProps<T>) => {\n  const visibleOptionCount =\n    typeof customVisibleOptionCount === 'number' ? Math.min(customVisibleOptionCount, options.length) : options.length\n  const optionMap = new OptionMap(options)\n  const defaultOption = typeof defaultValue === 'undefined' ? undefined : optionMap.get(defaultValue)\n  let option = defaultOption && !defaultOption.disabled ? defaultOption : optionMap.first\n\n  while (option && option.disabled) {\n    option = option.next\n  }\n\n  return {\n    optionMap,\n    visibleOptionCount,\n    visibleFromIndex: 0,\n    visibleToIndex: visibleOptionCount - 1,\n    value: option?.value,\n    previousValue: option?.value,\n  }\n}\n\nexport const useSelectState = <T>({visibleOptionCount, options, defaultValue}: UseSelectStateProps<T>) => {\n  const [state, dispatch] = useReducer(reducer, {visibleOptionCount, defaultValue, options}, createDefaultState)\n  const [lastOptions, setLastOptions] = useState(options)\n  const [lastVisibleOptionCount, setLastVisibleOptionCount] = useState(visibleOptionCount)\n\n  if (options !== lastOptions && !isDeepStrictEqual(options, lastOptions)) {\n    dispatch({\n      type: 'reset',\n      state: createDefaultState({visibleOptionCount, defaultValue, options}),\n    })\n\n    setLastOptions(options)\n  }\n\n  if (visibleOptionCount !== lastVisibleOptionCount) {\n    dispatch({\n      type: 'reset',\n      state: createDefaultState({visibleOptionCount, defaultValue, options}),\n    })\n\n    setLastVisibleOptionCount(visibleOptionCount)\n  }\n\n  const selectNextOption = useCallback(() => {\n    dispatch({\n      type: 'select-next-option',\n    })\n  }, [])\n\n  const selectPreviousOption = useCallback(() => {\n    dispatch({\n      type: 'select-previous-option',\n    })\n  }, [])\n\n  const selectOption = useCallback(({option}: {option: Option<T>}) => {\n    dispatch({\n      type: 'select-option',\n      option,\n    })\n  }, [])\n\n  const visibleOptions = useMemo(() => {\n    return options.slice(state.visibleFromIndex)\n  }, [options, state.visibleFromIndex])\n\n  return {\n    visibleFromIndex: state.visibleFromIndex,\n    visibleToIndex: state.visibleToIndex,\n    value: state.value,\n    visibleOptions,\n    selectNextOption,\n    selectPreviousOption,\n    selectOption,\n    previousValue: state.previousValue,\n  }\n}\n"]}