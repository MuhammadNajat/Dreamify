{"version":3,"file":"id-matching.js","sourceRoot":"","sources":["../../../../src/cli/services/context/id-matching.ts"],"names":[],"mappings":"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","sourcesContent":["import {RemoteSource, LocalSource} from './identifiers.js'\nimport {IdentifiersExtensions} from '../../models/app/identifiers.js'\nimport {groupBy, partition} from '@shopify/cli-kit/common/collection'\nimport {uniqBy, difference} from '@shopify/cli-kit/common/array'\nimport {pickBy} from '@shopify/cli-kit/common/object'\nimport {slugify} from '@shopify/cli-kit/common/string'\n\nexport interface LocalRemoteSource {\n  local: LocalSource\n  remote: RemoteSource\n}\n\nexport interface MatchResult {\n  identifiers: IdentifiersExtensions\n  toConfirm: LocalRemoteSource[]\n  toCreate: LocalSource[]\n  toManualMatch: {local: LocalSource[]; remote: RemoteSource[]}\n}\n\n/**\n * Filter function to match a local and a remote source by type and handle\n */\nconst sameTypeAndName = (local: LocalSource, remote: RemoteSource) => {\n  return remote.type === local.graphQLType && slugify(remote.title) === slugify(local.handle)\n}\n\n/**\n * Automatically match local and remote sources if they have the same type and handle\n *\n * If multiple local or remote sources have the same type and handle, they can't be matched automatically\n */\nfunction matchByNameAndType(\n  local: LocalSource[],\n  remote: RemoteSource[],\n  remoteIdField: 'id' | 'uuid',\n): {matched: IdentifiersExtensions; pending: {local: LocalSource[]; remote: RemoteSource[]}} {\n  const uniqueLocal = uniqBy(local, (elem) => [elem.graphQLType, elem.handle])\n  const uniqueRemote = uniqBy(remote, (elem) => [elem.type, elem.title])\n\n  const validMatches: IdentifiersExtensions = {}\n\n  uniqueLocal.forEach((localSource) => {\n    const possibleMatch = uniqueRemote.find((remoteSource) => sameTypeAndName(localSource, remoteSource))\n    if (possibleMatch) validMatches[localSource.localIdentifier] = possibleMatch[remoteIdField]\n  })\n\n  const pendingLocal = local.filter((elem) => !validMatches[elem.localIdentifier])\n  const pendingRemote = remote.filter(\n    (registration) => !Object.values(validMatches).includes(registration[remoteIdField]),\n  )\n  return {matched: validMatches, pending: {local: pendingLocal, remote: pendingRemote}}\n}\n\nfunction migrateLegacyFunctions(\n  ids: IdentifiersExtensions,\n  localSources: LocalSource[],\n  remoteSources: RemoteSource[],\n): {\n  migrated: IdentifiersExtensions\n  pending: {local: LocalSource[]; remote: RemoteSource[]}\n} {\n  const migrated: IdentifiersExtensions = {}\n  const pendingMigrations: IdentifiersExtensions = {}\n\n  remoteSources\n    .filter((extension) => extension.type === 'FUNCTION')\n    .forEach((functionExtension) => {\n      const config = functionExtension.draftVersion?.config\n      if (config === undefined) return\n\n      const parsedConfig = JSON.parse(config)\n      const legacyId = parsedConfig.legacy_function_id\n      if (legacyId) pendingMigrations[legacyId] = functionExtension.uuid\n\n      const legacyUuid = parsedConfig.legacy_function_uuid\n      if (legacyUuid) pendingMigrations[legacyUuid] = functionExtension.uuid\n    })\n\n  localSources\n    .filter((extension) => extension.type === 'function')\n    .forEach((functionExtension) => {\n      const localId = ids[functionExtension.localIdentifier]\n      if (localId === undefined) return\n\n      const remoteId = pendingMigrations[localId]\n      if (remoteId) {\n        delete pendingMigrations[functionExtension.localIdentifier]\n        migrated[functionExtension.localIdentifier] = remoteId\n      }\n    })\n\n  const pendingLocal = localSources.filter((elem) => !migrated[elem.localIdentifier])\n  const pendingRemote = remoteSources.filter((registration) => !Object.values(migrated).includes(registration.uuid))\n\n  return {\n    migrated,\n    pending: {\n      local: pendingLocal,\n      remote: pendingRemote,\n    },\n  }\n}\n\n/**\n * Ask the user to confirm the relationship between a local source and a remote source if they\n * the only ones of their types.\n */\nfunction matchByUniqueType(\n  localSources: LocalSource[],\n  remoteSources: RemoteSource[],\n): {\n  toCreate: LocalSource[]\n  toConfirm: {local: LocalSource; remote: RemoteSource}[]\n  pending: {local: LocalSource[]; remote: RemoteSource[]}\n} {\n  const localGroups = groupBy(localSources, 'graphQLType')\n  const localUnique = Object.values(pickBy(localGroups, (group, key) => group.length === 1)).flat()\n\n  const remoteGroups = groupBy(remoteSources, 'type')\n  const remoteUniqueMap = pickBy(remoteGroups, (group, key) => group.length === 1)\n\n  const toConfirm: {local: LocalSource; remote: RemoteSource}[] = []\n  const toCreate: LocalSource[] = []\n\n  // for every local source that has a unique type we either:\n  // - find a corresponding unique remote source and ask the user to confirm\n  // - create it from scratch\n  for (const local of localUnique) {\n    const remote = remoteUniqueMap[local.graphQLType]\n    if (remote && remote[0]) {\n      toConfirm.push({local, remote: remote[0]})\n    } else {\n      toCreate.push(local)\n    }\n  }\n\n  // now for every local source with a duplicated type we check\n  // if there is a remote source with the same type. if the answer is no,\n  // it means that we need to create them.\n  const localDuplicated = difference(localSources, localUnique)\n  const remotePending = difference(\n    remoteSources,\n    toConfirm.map((elem) => elem.remote),\n  )\n  const [localPending, localToCreate] = partition(localDuplicated, (local) =>\n    remotePending.map((remote) => remote.type).includes(local.graphQLType),\n  )\n  toCreate.push(...localToCreate)\n\n  return {\n    toCreate,\n    toConfirm,\n    pending: {\n      local: localPending,\n      remote: remotePending,\n    },\n  }\n}\n\n/**\n * Automatically match local sources to remote sources.\n * If we can't match a local source to any remote sources, we can create it.\n * If we are unsure about the matching we can ask the user to confirm the relationship.\n */\nexport async function automaticMatchmaking(\n  localSources: LocalSource[],\n  remoteSources: RemoteSource[],\n  identifiers: IdentifiersExtensions,\n  remoteIdField: 'id' | 'uuid',\n): Promise<MatchResult> {\n  const ids = getExtensionIds(localSources, identifiers)\n  const localUUIDs = Object.values(ids)\n\n  const existsRemotely = (local: LocalSource) =>\n    remoteSources.some(\n      (remote) => remote[remoteIdField] === ids[local.localIdentifier] && remote.type === local.graphQLType,\n    )\n\n  const {migrated: migratedFunctions, pending: pendingAfterMigratingFunctions} = migrateLegacyFunctions(\n    ids,\n    localSources.filter((local) => !existsRemotely(local)),\n    remoteSources.filter((remote) => !localUUIDs.includes(remote[remoteIdField])),\n  )\n\n  // We try to automatically match sources if they have the same name and type,\n  // by considering local sources which are missing on the remote side and\n  // remote sources which are not synchronized locally.\n  const {matched: matchedByNameAndType, pending: matchResult} = matchByNameAndType(\n    pendingAfterMigratingFunctions.local,\n    pendingAfterMigratingFunctions.remote,\n    remoteIdField,\n  )\n\n  // Now we try to find a match between a local source and remote one if they have\n  // the same type and they are unique even if they have different names. For example:\n  // LOCAL_CHECKOUT_UI_NAMED_APPLE -> REMOTE_CHECKOUT_UI_NAMED_PEAR\n  // LOCAL_PROD_SUBSCR_NAMED_ORANGE -> REMOTE_PROD_SUBSCR_NAMED_LEMON\n  const {toConfirm, toCreate, pending} = matchByUniqueType(matchResult.local, matchResult.remote)\n\n  return {\n    identifiers: {...ids, ...matchedByNameAndType, ...migratedFunctions},\n    toConfirm,\n    toCreate,\n    toManualMatch: pending,\n  }\n}\n\nexport function getExtensionIds(\n  localSources: LocalSource[],\n  identifiers: IdentifiersExtensions,\n): IdentifiersExtensions {\n  const localSourcesIds = localSources.map((source) => source.localIdentifier)\n\n  return pickBy(identifiers, (_, id) => localSourcesIds.includes(id))\n}\n"]}