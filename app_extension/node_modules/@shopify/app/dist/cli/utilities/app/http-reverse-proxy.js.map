{"version":3,"file":"http-reverse-proxy.js","sourceRoot":"","sources":["../../../../src/cli/utilities/app/http-reverse-proxy.ts"],"names":[],"mappings":"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","sourcesContent":["import {getAvailableTCPPort} from '@shopify/cli-kit/node/tcp'\nimport {AbortController, AbortSignal} from '@shopify/cli-kit/node/abort'\nimport Server from 'http-proxy'\nimport {OutputProcess, outputDebug, outputContent, outputToken, outputWarn} from '@shopify/cli-kit/node/output'\nimport {Writable} from 'stream'\nimport * as http from 'http'\n\nexport interface ReverseHTTPProxyTarget {\n  /** The prefix to include in the logs\n   *   [vite] Output coming from Vite\n   */\n  logPrefix: string\n\n  /**\n   * The port to use for the target HTTP server. When undefined, a random port is automatically assigned.\n   */\n  customPort?: number\n\n  /**\n   * The HTTP path prefix used to match against request and determine if the traffic should be\n   * forwarded to this target\n   */\n  pathPrefix?: string\n\n  /**\n   * The configuration for a separate HMR server for this target.\n   */\n  hmrServer?: {\n    port: number\n    httpPaths: string[]\n  }\n\n  /**\n   * A callback to invoke the process. stdout and stderr should be used\n   * to send standard output and error data that gets formatted with the\n   * right prefix.\n   */\n  action: (stdout: Writable, stderr: Writable, signal: AbortSignal, port: number) => Promise<void> | void\n}\n\ninterface Options {\n  portNumber: number\n  proxyTargets: ReverseHTTPProxyTarget[]\n  additionalProcesses: OutputProcess[]\n  abortController: AbortController\n}\n\n/**\n * A convenient function that runs an HTTP server and does path-based traffic forwarding to sub-processes that run\n * an HTTP server. The method assigns a random port to each of the processes.\n * @param tunnelUrl - The URL of the tunnel.\n * @param portNumber - The port to use for the proxy HTTP server. When undefined, a random port is automatically assigned.\n * @param proxyTargets - List of target processes to forward traffic to.\n * @param additionalProcesses - Additional processes to run. The proxy won't forward traffic to these processes.\n * @returns A promise that resolves with an interface to get the port of the proxy and stop it.\n */\nexport async function runConcurrentHTTPProcessesAndPathForwardTraffic({\n  portNumber,\n  proxyTargets,\n  additionalProcesses,\n  abortController,\n}: Options): Promise<OutputProcess[]> {\n  if (proxyTargets.length === 0) {\n    return [...additionalProcesses]\n  }\n\n  const {rules, processDefinitions} = await createProcessDefinitionsForProxies(proxyTargets)\n\n  outputDebug(outputContent`\nStarting reverse HTTP proxy on port ${outputToken.raw(portNumber.toString())}\nRouting traffic rules:\n${outputToken.json(JSON.stringify(rules))}\n`)\n  const {server} = await getProxyingWebServer(rules, abortController.signal)\n\n  return [\n    {\n      prefix: 'proxy',\n      action: async () => {\n        await server.listen(portNumber)\n      },\n    },\n    ...processDefinitions,\n    ...additionalProcesses,\n  ]\n}\n\nexport async function getProxyingWebServer(rules: {[key: string]: string}, abortSignal: AbortController['signal']) {\n  // Lazy-importing it because it's CJS and we don't want it\n  // to block the loading of the ESM module graph.\n  const {default: httpProxy} = await import('http-proxy')\n  const proxy = httpProxy.createProxy()\n  const server = http.createServer(getProxyServerRequestListener(rules, proxy))\n\n  // Capture websocket requests and forward them to the proxy\n  server.on('upgrade', getProxyServerWebsocketUpgradeListener(rules, proxy))\n\n  abortSignal.addEventListener('abort', () => {\n    outputDebug('Closing reverse HTTP proxy')\n    server.close()\n  })\n  return {server}\n}\n\nfunction getProxyServerWebsocketUpgradeListener(\n  rules: {[key: string]: string},\n  proxy: Server,\n): (req: http.IncomingMessage, socket: import('stream').Duplex, head: Buffer) => void {\n  return function (req, socket, head) {\n    const target = match(rules, req, true)\n    if (target) {\n      return proxy.ws(req, socket, head, {target}, (err) => {\n        outputWarn(`Error forwarding websocket request: ${err}`)\n      })\n    }\n    socket.destroy()\n  }\n}\n\nfunction getProxyServerRequestListener(\n  rules: {[key: string]: string},\n  proxy: Server,\n): http.RequestListener<typeof http.IncomingMessage, typeof http.ServerResponse> | undefined {\n  return function (req, res) {\n    const target = match(rules, req)\n    if (target) {\n      return proxy.web(req, res, {target}, (err) => {\n        outputWarn(`Error forwarding web request: ${err}`)\n      })\n    }\n\n    outputDebug(`\nReverse HTTP proxy error - Invalid path: ${req.url}\nThese are the allowed paths:\n${outputToken.json(JSON.stringify(rules))}\n`)\n\n    res.statusCode = 500\n    res.end(`Invalid path ${req.url}`)\n  }\n}\n\nasync function createProcessDefinitionsForProxies(proxyTargets: ReverseHTTPProxyTarget[]) {\n  const rules: {[key: string]: string} & {websocket?: string} = {}\n\n  const createProxyProcessDefinition = async (target: ReverseHTTPProxyTarget): Promise<OutputProcess> => {\n    const targetPort = target.customPort || (await getAvailableTCPPort())\n    rules[target.pathPrefix ?? 'default'] = `http://localhost:${targetPort}`\n    const hmrServer = target.hmrServer\n    if (hmrServer) {\n      rules.websocket = `http://localhost:${hmrServer.port}`\n      hmrServer.httpPaths.forEach((path) => (rules[path] = `http://localhost:${hmrServer.port}`))\n    }\n\n    return {\n      prefix: target.logPrefix,\n      action: async (stdout, stderr, signal) => {\n        await target.action(stdout, stderr, signal, targetPort)\n      },\n    }\n  }\n  const proxyProcessDefinitions = proxyTargets.map(createProxyProcessDefinition)\n  const processDefinitions = await Promise.all(proxyProcessDefinitions)\n  return {rules, processDefinitions}\n}\n\nfunction match(rules: {[key: string]: string}, req: http.IncomingMessage, websocket = false) {\n  const path: string = req.url ?? '/'\n\n  for (const pathPrefix in rules) {\n    if (path.startsWith(pathPrefix)) return rules[pathPrefix]\n  }\n\n  if (websocket && rules.websocket) return rules.websocket\n\n  return rules.default\n}\n"]}